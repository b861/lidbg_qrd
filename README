linux debug(lidbg)
项目说明：此项目是以调试为目的，方便调试和控制外设（如在终端直接控制i2c，io，spi，读内存寄存器等）。
		  后来运用在产品中，目前我们写的驱动均是以ko的形式加载运行，代码集成在lidbg_qrd中。

----------代码下载方法----------
下载：git clone qcom_share@192.168.9.222:/home/qcom_share/lidbg_qrd
密码：小写字母 l

----------代码结构--------------
主要包含应用层（android），基础驱动模块（core），具体工作模块（drivers），编译脚本（build），输出目录（out/out_release）。

*应用层（android）
android/JAVA:                          提供一些函数模块，可直接用于上层java代码中（例如把java程序中的打印信息输出到串口）。
android/msm8x25/lidbg_servicer：       用于加载第三方模块，接收内核模块的消息作相应处理，在内核层不方便实现的功能在此处理。
android/msm8x25/uart_send_rec_test：   用于串口稳定性测试。
android/msm8x25/usb_sd_mount_test：    用于U盘和SD卡插拔稳定性测试。
android/msm8x25/fileserver：           上层apk，用于在界面形式与lidbg中的驱动进行交互（需要在3G拨号界面输入*#*#158999#*#*）。
android/msm8x25/client_mobile：        上层apk，采用socket通信将本机调试信息上传到服务器（192.168.9.222）。
android/msm8x25/lidbg_gui：            用于将内核信息输出到LCD屏。
android/msm8x25/8x25q_camera：         8x25q产品的关于摄像头的HAL模块代码。
android/msm8x25/gpslib：               gps驱动对应的HAL模块代码
android/out：                          编译后自动生成， 应用层生成的目标文件。

*基础驱动模块（core）
作用主要有两个：
1.封装不同soc的底层实现（例如i2c / io / spi / ad / pwm等，在core/msm8x25目录），提供通用接口给其他模块。通过共享其包含指针函数的结构体地址，给其他模块（主要是drivers下的模块）调用。
2.创建节点/dev/mlidbg0，提供在shell终端控制外设调试的命令，具体的命令参考core\msm8x25\doc\echo_shell_msm8x25.txt。

*具体工作模块（drivers）
drivers下是在不同平台下的一些具体实际工作，为了保证其平台可移植性，尽量不要调用soc的底层函数，而是调用core提供的通用接口：
drivers/msm8x25/example：              调用core的函数接口例子。
drivers/msm8x25/bp_msg：               打印bp写入共享内存的调试信息。
drivers/msm8x25/devices：              控制系统正常运行和开关机中必须的外设。
drivers/msm8x25/fastboot：             处理msm8x25平台休眠唤醒相关。
drivers/msm8x25/acc：                  处理msm8x25Q平台休眠唤醒相关。
drivers/msm8x25/gps：                  ublox驱动。
drivers/msm8x25/touchscreen：          电容屏相关驱动。
drivers/msm8x25/videoin：              视频输入驱动。
drivers/msm8x25/hal：                  设置函数指针调用，并加载驱动模块（主要是drivers目录下的）。
drivers/msm8x25/inc：				   drivers下使用的头文件。


*编译脚本（build）
build：编译使用到的脚本。

输出目录（out/out_release）
out：编译后自动生成，存放所有编译生成的模块。
out_release：编译后自动生成，存放产品正式包需要的模块，由build/copy_out_release.sh脚本指定。
注：提供产品正式包时，使用lidbg_qrd目录下的release.sh编译，然后提供out_release下的out给系统组打包

----------编译方法----------
1.配置编译环境
cd lidbg_qrd
(1) cp ./core/msm8x25/doc/dbg_cfg_backup.sh ./dbg_cfg.sh
(2) 修改DBG_SYSTEM_DIR环境变量(指向的包的内核需编译过一遍(make bootimage))
(3) chmod 777  ./* -R
以上步骤只需配置一次

dbg_cfg.sh编译环境变量配置说明：
＊DBG_PLATFORM:
msm7627a--8x25平台
msm8625--8x25q平台

＊BUILD_VERSION
dbg--编译出运行在原生系统的模块
rel--编译出运行在发布产品系统的模块

*BOARD_VERSION
v1--适用于8x25第一版硬件（pcb）
v2--适用于8x25第二版及最后量产硬件（pcb）
v3--适用于8x25q车机第一版硬件（pcb）
V4--新架构程序版本，适用于8x25q第一版硬件之后的版本（pcb）


2.编译
*模块提供两种方法
(1) 编译所有模块，在lidbg根目录运行build.sh
(2) 编译单独模块，如在lidbg根目录执行:
./make.sh drivers/msm8x25/gps
./make.sh core
生成模块在out目录

*应用层（android）的编译
在android目录下的build_all.sh脚本,生成模块(apk、可执行文件等)在android/out目录

3.运行clean.sh可清除所有编译后产生的文件。


--------------运行-------------
正式产品包已经默认加载lidbg相关模块，要是想push自己的lidbg模块到机器执行，执行下面指令：
原生系统执行 
build/push.sh

产品系统执行 
build/pushfly.sh

以下两种方法均可运行模块
1.在终端用insmod指令直接加载模块（默认加载的原生系统，/system/lib/modules目录）
执行 build/insmod.sh  (正式产品是flysystem/lib/out目录)

2. 开机自动运行lidbg_servicer和lidbg_loader.ko加载模块
*8x25:
把lidbg_servicer打包进系统，在文件system/core/rootdir/etc/init.qcom.rc添加
chmod 777 /system/bin/lidbg_servicer  (正式产品是/flysystem/bin目录)
和
service lidbg_servicer /system/bin/logwrapper /system/bin/lidbg_servicer  (正式产品是/flysystem/bin目录)
    class late_start
    user root
    group root

*8x25Q:
a.原生系统：在文件device/qcom/common/rootdir/etc/init.qcom.rc添加
	on boot 
	chmod 0644 /system/lib/modules/out/*.ko
    insmod /system/lib/modules/out/lidbg_loader.ko
	
b.产品系统：在文件system/core/rootdir/init.flyaudio.rc添加
	on boot 
    chmod 0644 /flysystem/lib/out/*.ko
    insmod /flysystem/lib/out/lidbg_loader.ko
和
service lidbg_servicer /system/bin/logwrapper /flysystem/lib/out/lidbg_servicer
    class late_start
    user root
    group root 	

-------------集成到系统镜像-------------
执行build/copy2img.sh后重新make编译系统即可


-------------git使用注意事项-------------
1.参考qcom_share 的《git提交规范.txt》
2.个人的测试代码不要push 到服务器master分支，如需要可创建自己的测试分支再push这个分支到服务器。
把本地分支(locate_branch_name) push到服务器(remote_branch_name)
git push origin locate_branch_name:remote_branch_name 
查看远程分支
git branch -r
git pull origin remote_branch_name:locate_branch_name
